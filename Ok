const fs = require("fs-extra");
const path = require("path");
const axios = require("axios");
const { createCanvas, loadImage } = require("canvas");

const cacheDir = path.join(__dirname, 'tmp');
if (!fs.existsSync(cacheDir)) {
  fs.mkdirSync(cacheDir);
}

module.exports = {
  config: {
    name: 'fx',
    aliases: [],
    version: '1.1',
    role: 2,
    countDown: 5,
    author: 'Vincenzo',
    category: 'AI',
    guide: { 
      en: 'Use the command followed by your prompt and optionally add parameters for style (--style) and seed (--seed). For example:\n{pn} cute cat --style 3 --seed 12345\n{pn} cute cat --style 3\n{pn} cute cat\n\nAvailable Styles:\n1. Cinematic\n2. Photographic\n3. Anime\n4. Manga\n5. Digital Art\n6. Pixel Art\n7. Fantasy Art\n8. Neon Punk\n9. 3D Model'
    }
  },
  onStart: async ({ event, message, api, args }) => {
    let prompt = '';
    let style = '';
    let seed = '';

    args.forEach(arg => {
      if (arg.startsWith('--style=')) {
        style = arg.slice(8);
      } else if (arg.startsWith('--seed=')) {
        seed = arg.slice(7);
      } else {
        prompt += `${arg} `;
      }
    });

    prompt = prompt.trim(); // Remove extra spaces
    const endpoint = `smfahim.xyz/flux2?prompt=${encodeURIComponent(prompt)}${style ? `&style=${style}` : ''}${seed ? `&seed=${seed}` : ''}`;

    try {
      message.reply('Generating images, please wait... ⏰', event.messageID);

      const images = [];
      const numImages = 4;

      for (let i = 0; i < numImages; i++) {
        const response = await axios.get(endpoint);

        if (response.data.success) {
          const imageURL = response.data.imageUrl;
          const imagePath = path.join(cacheDir, `image_${Date.now()}_${i}.jpg`);

          const writer = fs.createWriteStream(imagePath);
          const imageResponse = await axios({
            url: imageURL,
            method: 'GET',
            responseType: 'stream'
          });
          imageResponse.data.pipe(writer);

          await new Promise((resolve, reject) => {
            writer.on('finish', resolve);
            writer.on('error', reject);
          });

          images.push(imagePath);
        } else {
          message.reply("❌ Failed to generate image. Try Again!");
          return;
        }
      }

      const width = 1024;  // Default width for combined image
      const height = 1024; // Default height for combined image
      const canvas = createCanvas(width * 2, height * 2);
      const ctx = canvas.getContext('2d');

      const positions = [
        { x: 0, y: 0 },
        { x: width, y: 0 },
        { x: 0, y: height },
        { x: width, y: height }
      ];

      for (let i = 0; i < numImages; i++) {
        const img = await loadImage(images[i]);
        ctx.drawImage(img, positions[i].x, positions[i].y, width, height);
      }

      const combinedImagePath = path.join(cacheDir, `combined_image_${Date.now()}.jpg`);
      const out = fs.createWriteStream(combinedImagePath);
      const stream = canvas.createJPEGStream();
      stream.pipe(out);

      await new Promise((resolve, reject) => {
        out.on('finish', resolve);
        out.on('error', reject);
      });

      const combinedImageStream = fs.createReadStream(combinedImagePath);
      const sentMessage = await message.reply({ body: 'Images Generated. Reply with 1, 2, 3, or 4 to select an image.', attachment: combinedImageStream });

      const waitForResponse = async () => {
        while (true) {
          const history = await api.getThreadHistory(event.threadID, 1, null, null, sentMessage.messageID);
          const response = history[0];

          if (response && response.senderID === event.senderID) {
            const body = response.body;

            if (typeof body === 'string') {
              const choice = parseInt(body.replace(/\s+/g, ''), 10); // Remove spaces and convert to number
              if (!isNaN(choice) && choice >= 1 && choice <= 4) {
                return choice;
              }
            }
          }
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      };

      const userChoice = await waitForResponse();

      if (userChoice) {
        const selectedImageStream = fs.createReadStream(images[userChoice - 1]);
        await message.reply({ attachment: selectedImageStream }, () => {
          images.forEach(imgPath => fs.unlinkSync(imgPath));
          fs.unlinkSync(combinedImagePath);
        });
      }

    } catch (err) {
      console.error("Error:", err.message);
      message.reply(`❌ Error: ${err.message}`);
    }
  }
};
